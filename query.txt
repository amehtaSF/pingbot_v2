
I am making a ecological momentary assessment app with flask backend and react frontend. 
Here are some of the files that I have created so far:
flask_app/app.py
``` python
from logger_setup import setup_logger
import json
from flask import Flask, request, jsonify
import os
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
import boto3
from datetime import datetime, timedelta
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import hashlib
from dotenv import load_dotenv
from flask import Response


# Load environment variables
load_dotenv()

# Initialize logger
logger = setup_logger()

# Initialize PostgreSQL database
db = SQLAlchemy()

# Initialize JWT manager
jwt = JWTManager()

def create_app(config='config.Config'):
    
    app = Flask(__name__)
    CORS(app)

    # Attach logger to app
    app.logger = logger
    
    # Load config
    try:
        app.config.from_object(config)
    except Exception as e:
        logger.error(f"Failed to load configuration: {e}")
        raise

    # Extensions
    jwt.init_app(app)
    db.init_app(app)
    
    # Blueprints
    # from blueprints.admin import admin_bp
    from blueprints.auth import auth_bp
    # from blueprints.users import users_bp
    # from blueprints.bot import bot_bp
    # from blueprints.participants import participants_bp
    
    # app.register_blueprint(admin_bp, url_prefix='/admin')
    app.register_blueprint(auth_bp, url_prefix='/auth')
    # app.register_blueprint(bot_bp, url_prefix='/bot')
    # app.register_blueprint(participants_bp, url_prefix='/participants')
    # app.register_blueprint(users_bp, url_prefix='/')
    
    # @app.before_request
    # def log_request():
    #     print(f"Request received: {request.method} {request.url}")
        
    # Health Check
    @app.route('/health', methods=['GET'])
    def health():
        return {'status': 'healthy'}, 200
    
    # Generic error handling
    @app.errorhandler(Exception)
    def handle_exception(e):
        logger.exception(e)
        return {'error': str(e)}, 500
    
    return app

```

flask_app/models.py
``` python
import os
from datetime import datetime
from dotenv import load_dotenv
from werkzeug.security import generate_password_hash, check_password_hash

from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy import Interval

from app import db, create_app

load_dotenv()

# ------------------------------------------------
# Many-to-many association table for users â†” studies
# ------------------------------------------------
user_studies = db.Table(
    'user_studies',
    db.Column('user_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),
    db.Column('study_id', db.Integer, db.ForeignKey('studies.id'), primary_key=True)
)

# ------------------------------------------------
# 1) Users Table
#    columns: id, email, password, first_name, last_name, institution
# ------------------------------------------------
class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    email = db.Column(db.String(255), nullable=False, unique=True)
    password = db.Column(db.String(255), nullable=False)
    first_name = db.Column(db.String(100))
    last_name = db.Column(db.String(100))
    institution = db.Column(db.String(255))

    # Many-to-many relationship with Study
    studies = db.relationship(
        "Study",
        secondary=user_studies,
        back_populates="users"
    )
    
    def set_password(self, password):
        """Hash and set the user's password."""
        self.password = generate_password_hash(password)
        
    def check_password(self, password):
        """Check if the provided password matches the stored hash."""
        return check_password_hash(self.password, password)

# ------------------------------------------------
# 2) Studies Table
#    columns: id, public_name, internal_name
# ------------------------------------------------
class Study(db.Model):
    __tablename__ = 'studies'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    public_name = db.Column(db.String(255), nullable=False)
    internal_name = db.Column(db.String(255), nullable=False)

    # One-to-many relationships
    ping_templates = db.relationship("PingTemplate", back_populates="study")
    pings = db.relationship("Ping", back_populates="study")

    # Many-to-many relationship with User
    users = db.relationship(
        "User",
        secondary=user_studies,
        back_populates="studies"
    )

# ------------------------------------------------
# 3) Participants Table
#    columns: id, telegram_id, tz
# ------------------------------------------------
class Participant(db.Model):
    __tablename__ = 'participants'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    telegram_id = db.Column(db.String(100), nullable=False, unique=True)
    tz = db.Column(db.String(50), nullable=False)

    # One-to-many relationship
    pings = db.relationship("Ping", back_populates="participant")

# ------------------------------------------------
# 4) PingTemplates Table
#    columns: id, name, message, url, reminder_latency,
#             expire_latency, start_day_num, schedule
# ------------------------------------------------
class PingTemplate(db.Model):
    __tablename__ = 'ping_templates'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)

    name = db.Column(db.String(255), nullable=False)
    message = db.Column(db.Text, nullable=False)
    url = db.Column(db.String(255))
    reminder_latency = db.Column(Interval)  # e.g., '1 hour', '30 minutes'
    expire_latency = db.Column(Interval)    # e.g., '24 hours'
    start_day_num = db.Column(db.Integer)
    # Use JSONB to store a JSON list of dicts (PostgreSQL only)
    schedule = db.Column(JSONB, nullable=True)

    # Relationship back to Study
    study = db.relationship("Study", back_populates="ping_templates")

    # Relationship to Pings
    pings = db.relationship("Ping", back_populates="ping_template")

# ------------------------------------------------
# 5) Pings Table
#    columns: id, scheduled_ts, expire_ts, reminder_ts, day_num, url,
#             ping_sent, reminder_sent
# ------------------------------------------------
class Ping(db.Model):
    __tablename__ = 'pings'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    ping_template_id = db.Column(db.Integer, db.ForeignKey('ping_templates.id'), nullable=False)
    participant_id = db.Column(db.Integer, db.ForeignKey('participants.id'), nullable=False)

    # Timestamps in UTC => DateTime(timezone=True)
    scheduled_ts = db.Column(db.DateTime(timezone=True), nullable=False)
    expire_ts = db.Column(db.DateTime(timezone=True))
    reminder_ts = db.Column(db.DateTime(timezone=True))

    day_num = db.Column(db.Integer, nullable=False)
    url = db.Column(db.String(255))
    ping_sent = db.Column(db.Boolean, nullable=False, default=False)
    reminder_sent = db.Column(db.Boolean, nullable=False, default=False)

    # Relationships
    study = db.relationship("Study", back_populates="pings")
    ping_template = db.relationship("PingTemplate", back_populates="pings")
    participant = db.relationship("Participant", back_populates="pings")


def create_tables():
    """
    Creates all tables in the database by invoking db.create_all()
    within a Flask application context.
    """
    # We use create_app from your app.py to get an application context
    app = create_app()
    with app.app_context():
        db.create_all()
        print("All tables created successfully!")```

flask_app/blueprints/studies.py
``` python
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from app import db

from models import User, Study

studies_bp = Blueprint('studies', __name__)

def get_current_user():
    """Helper function to get the current user object from the JWT."""
    user_id = get_jwt_identity()
    if not user_id:
        return None
    return db.session.get(User, user_id)


def user_owns_study(user, study_id):
    """
    Helper function to check if the user is part of (has access to) the given study_id.
    Returns the Study object if found; otherwise returns None.
    """
    # Option 1: check if the study is in user.studies (which might already be loaded).
    # But for large data sets or if user.studies is not dynamic, let's do a proper query:
    study = (
        db.session.query(Study)
        .join(Study.users)  # Join to the 'users' relationship
        .filter(Study.id == study_id, User.id == user.id)
        .first()
    )
    return study


@studies_bp.route('/studies', methods=['GET'])
@jwt_required()
def get_studies():
    """
    Returns a paginated list of Studies that the current user has access to.
    Example usage:
      GET /studies?page=1&per_page=10
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    # Query all studies for this user, then paginate
    query = (
        db.session.query(Study)
        .join(Study.users)       # Join the association to check membership
        .filter(User.id == user.id)
        .order_by(Study.id.asc())  # For example, sort by ID ascending
    )

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    studies_list = []
    for st in pagination.items:
        studies_list.append({
            "id": st.id,
            "public_name": st.public_name,
            "internal_name": st.internal_name
        })

    return jsonify({
        "data": studies_list,
        "meta": {
            "page": pagination.page,
            "per_page": pagination.per_page,
            "total": pagination.total,
            "pages": pagination.pages
        }
    }), 200


@studies_bp.route('/studies', methods=['POST'])
@jwt_required()
def create_study():
    """
    Creates a new Study and associates it with the current user.
    Expects JSON body: {"public_name": "...", "internal_name": "..."}
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    data = request.get_json()
    public_name = data.get('public_name')
    internal_name = data.get('internal_name')

    if not public_name or not internal_name:
        return jsonify({"error": "Missing required fields: public_name, internal_name"}), 400

    new_study = Study(
        public_name=public_name,
        internal_name=internal_name
    )

    # Associate this study with the current user
    new_study.users.append(user)

    current_app.session.add(new_study)
    db.session.commit()

    return jsonify({
        "message": "Study created successfully",
        "study": {
            "id": new_study.id,
            "public_name": new_study.public_name,
            "internal_name": new_study.internal_name
        }
    }), 201


@studies_bp.route('/studies/<int:study_id>', methods=['GET'])
@jwt_required()
def get_single_study(study_id):
    """
    Returns a single study, if the user is part of it.
    GET /studies/<study_id>
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    study = user_owns_study(user, study_id)
    if not study:
        return jsonify({"error": f"Study {study_id} not found or no access"}), 404

    return jsonify({
        "id": study.id,
        "public_name": study.public_name,
        "internal_name": study.internal_name
    }), 200


@studies_bp.route('/studies/<int:study_id>', methods=['PUT'])
@jwt_required()
def update_study(study_id):
    """
    Updates a study if the user has access to it.
    Expects JSON body with any of: {"public_name": "...", "internal_name": "..."}.
    PUT /studies/<study_id>
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    study = user_owns_study(user, study_id)
    if not study:
        return jsonify({"error": f"Study {study_id} not found or no access"}), 404

    data = request.get_json()
    if 'public_name' in data:
        study.public_name = data['public_name']
    if 'internal_name' in data:
        study.internal_name = data['internal_name']

    db.session.commit()

    return jsonify({
        "message": "Study updated successfully",
        "study": {
            "id": study.id,
            "public_name": study.public_name,
            "internal_name": study.internal_name
        }
    }), 200


@studies_bp.route('/studies/<int:study_id>', methods=['DELETE'])
@jwt_required()
def delete_study(study_id):
    """
    Deletes a study if the user has access to it.
    DELETE /studies/<study_id>
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    study = user_owns_study(user, study_id)
    if not study:
        return jsonify({"error": f"Study {study_id} not found or no access"}), 404

    # If multiple users share this study, consider whether you truly want
    # to delete the entire record or just remove the user's association.
    # For this example, let's assume we delete it entirely.
    db.session.delete(study)
    db.session.commit()

    return jsonify({"message": f"Study {study_id} deleted successfully."}), 200```


Please fill in the empty functions in the studies.py file.
