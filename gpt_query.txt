flask_app/models.py
``` python
import os
from datetime import datetime, timezone
from dotenv import load_dotenv
from werkzeug.security import generate_password_hash, check_password_hash

from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy import Interval

from app import db, create_app

load_dotenv()

# ------------------------------------------------
# Enrollments Table
# ------------------------------------------------
class Enrollment(db.Model):
    __tablename__ = 'enrollments'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    
    telegram_id = db.Column(db.String(100), nullable=True, unique=False)
    telegram_link_code = db.Column(db.String(255), nullable=True)
    telegram_link_code_expire_ts = db.Column(db.DateTime(timezone=True), nullable=True)
    telegram_link_code_used = db.Column(db.Boolean, default=False, nullable=False)
    
    tz = db.Column(db.String(50), nullable=False)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    study_pid = db.Column(db.String(255), nullable=False)  # Participant ID in the study assigned by researcher
    enrolled = db.Column(db.Boolean, default=True, nullable=False)
    start_date = db.Column(db.DateTime(timezone=True), nullable=False)
    pr_completed = db.Column(db.Float, default=0.0)
    
    dashboard_otp = db.Column(db.String(255), nullable=True)
    dashboard_otp_expire_ts = db.Column(db.DateTime(timezone=True), nullable=True)
    dashboard_otp_used = db.Column(db.Boolean, default=False, nullable=False)
    
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))

    # Relationships
    pings = db.relationship("Ping", back_populates="enrollment")
    study = db.relationship("Study", back_populates="enrollments")
    
    def to_dict(self):
        return {
            'id': self.id,
            'telegram_id': self.telegram_id,
            'telegram_link_code': self.telegram_link_code,
            'telegram_link_code_expire_ts': self.telegram_link_code_expire_ts.isoformat() if self.telegram_link_code_expire_ts else None,
            'telegram_link_code_used': self.telegram_link_code_used,
            'tz': self.tz,
            'study_id': self.study_id,
            'study_pid': self.study_pid,
            'enrolled': self.enrolled,
            'start_date': self.start_date.isoformat() if self.start_date else None,
            'pr_completed': self.pr_completed,
            'dashboard_otp': self.dashboard_otp,
            'dashboard_otp_expire_ts': self.dashboard_otp_expire_ts.isoformat() if self.dashboard_otp_expire_ts else None,
            'dashboard_otp_used': self.dashboard_otp_used,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }
    

# ------------------------------------------------
# UserStudy Table (Users â†” Studies with attributes)
# ------------------------------------------------
class UserStudy(db.Model):
    __tablename__ = 'user_studies'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    role = db.Column(db.String(255), nullable=False)  # e.g. 'owner': sharing + editing + viewing, 'editor': editing + viewing, 'viewer': viewing only
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))

    # Relationships
    user = db.relationship("User", back_populates="user_studies")
    study = db.relationship("Study", back_populates="user_studies")
    
    def to_dict(self):
        return {
            'id': self.id,
            'user_id': self.user_id,
            'study_id': self.study_id,
            'role': self.role,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }

# ------------------------------------------------
# Users Table
# ------------------------------------------------
class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    email = db.Column(db.String(255), nullable=False, unique=True)
    password = db.Column(db.String(255), nullable=False)
    first_name = db.Column(db.String(100))
    last_name = db.Column(db.String(100))
    institution = db.Column(db.String(255))
    prolific_token = db.Column(db.String(255))
    last_login = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))

    # Many-to-many relationship with Study
    user_studies = db.relationship(
        "UserStudy",
        back_populates="user"
    )

    def set_password(self, password):
        """Hash and set the user's password."""
        self.password = generate_password_hash(password)
        
    def check_password(self, password):
        """Check if the provided password matches the stored hash."""
        return check_password_hash(self.password, password)
    
    def to_dict(self):
        return {
            'id': self.id,
            'email': self.email,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'institution': self.institution,
            'last_login': self.last_login.isoformat() if self.last_login else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }

# ------------------------------------------------
# Studies Table
# ------------------------------------------------
class Study(db.Model):
    __tablename__ = 'studies'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    public_name = db.Column(db.String(255), nullable=False)
    internal_name = db.Column(db.String(255), nullable=False)
    code = db.Column(db.String(255), nullable=False, unique=True)
    contact_message = db.Column(db.Text)  # e.g., "Please contact the study team for any questions or concerns by emailing ashm@stanford.edu."
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))

    # Relationships
    ping_templates = db.relationship("PingTemplate", back_populates="study")
    pings = db.relationship("Ping", back_populates="study")
    enrollments = db.relationship(
        "Enrollment",
        back_populates="study"
    )
    user_studies = db.relationship(
        "UserStudy",
        back_populates="study"
    ) 
    
    def to_dict(self):
        return {
            'id': self.id,
            'public_name': self.public_name,
            'internal_name': self.internal_name,
            'code': self.code,
            'contact_message': self.contact_message,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }
    
# ------------------------------------------------
# PingTemplates Table
# ------------------------------------------------
class PingTemplate(db.Model):
    __tablename__ = 'ping_templates'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    name = db.Column(db.String(255), nullable=False)
    message = db.Column(db.Text, nullable=False)
    url = db.Column(db.String(255))  # e.g., "https://qualtrics.com/survey"
    url_text = db.Column(db.String(255))  # e.g., "Click here to take the survey."
    reminder_latency = db.Column(Interval)  # e.g., '1 hour', '30 minutes'
    expire_latency = db.Column(Interval)    # e.g., '24 hours'
    schedule = db.Column(JSONB, nullable=True)  # e.g.,  [{"start_day_num": 1, "start_time": "09:00", "end_day_num": 1, "end_time": "10:00"}, {"day_num": 2, "start_time": "09:00", "end_time": "10:00"}]
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))

    # Relationships
    study = db.relationship("Study", back_populates="ping_templates")
    pings = db.relationship("Ping", back_populates="ping_template")
    
    def to_dict(self):
        return {
            'id': self.id,
            'study_id': self.study_id,
            'name': self.name,
            'message': self.message,
            'url': self.url,
            'url_text': self.url_text,
            'reminder_latency': str(self.reminder_latency),
            'expire_latency': str(self.expire_latency),
            'schedule': self.schedule,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }

# ------------------------------------------------
# Pings Table
# ------------------------------------------------
class Ping(db.Model):
    __tablename__ = 'pings'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    ping_template_id = db.Column(db.Integer, db.ForeignKey('ping_templates.id'), nullable=False)
    enrollment_id = db.Column(db.Integer, db.ForeignKey('enrollments.id'), nullable=False)
    
    scheduled_ts = db.Column(db.DateTime(timezone=True), nullable=False)
    expire_ts = db.Column(db.DateTime(timezone=True))
    reminder_ts = db.Column(db.DateTime(timezone=True))
    ping_sent = db.Column(db.Boolean, nullable=False, default=False)
    reminder_sent = db.Column(db.Boolean, nullable=False, default=False)
    
    forwarding_code = db.Column(db.String(255), nullable=False, default=lambda: os.urandom(16).hex())
    
    day_num = db.Column(db.Integer, nullable=False)
    
    message = db.Column(db.Text, nullable=False)
    url = db.Column(db.String(255), nullable=True)
    
    created_at = db.Column(db.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=lambda: datetime.now(timezone.utc))

    # Relationships
    study = db.relationship("Study", back_populates="pings")
    ping_template = db.relationship("PingTemplate", back_populates="pings")
    enrollment = db.relationship("Enrollment", back_populates="pings")
    # participant = db.relationship("Participant", back_populates="pings")
    
    def to_dict(self):
        return {
            'id': self.id,
            'study_id': self.study_id,
            'ping_template_id': self.ping_template_id,
            'enrollment_id': self.enrollment_id,
            'scheduled_ts': self.scheduled_ts.isoformat() if self.scheduled_ts else None,
            'expire_ts': self.expire_ts.isoformat() if self.expire_ts else None,
            'reminder_ts': self.reminder_ts.isoformat() if self.reminder_ts else None,
            'day_num': self.day_num,
            'message': self.message,
            'url': self.url,
            'ping_sent': self.ping_sent,
            'reminder_sent': self.reminder_sent,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }
```

react_frontend/src/pages/PingTemplateDashboard.js
```
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import StudyNav from '../components/StudyNav';
import axios from '../api/axios'; // your configured axios instance

function PingTemplateDashboard() {
  // -----------------------------------------
  // Get studyId from the URL parameter
  // -----------------------------------------
  const { studyId } = useParams();

  // -----------------------------------------
  // State
  // -----------------------------------------
  const [pingTemplates, setPingTemplates] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Pagination
  const [page, setPage] = useState(1);
  const [perPage] = useState(5);
  const [totalPages, setTotalPages] = useState(1);

  // Form fields for creating a new Ping Template
  const [name, setName] = useState('');
  const [message, setMessage] = useState('');
  const [url, setUrl] = useState('');
  const [reminderLatency, setReminderLatency] = useState('');
  const [expireLatency, setExpireLatency] = useState('');
  const [schedule, setSchedule] = useState('');

  // Toggle for "Create Ping Template" form
  const [showCreateForm, setShowCreateForm] = useState(false);

  // -----------------------------------------
  // Fetch ping templates whenever page or studyId changes
  // -----------------------------------------
  useEffect(() => {
    if (studyId) {
      fetchPingTemplates(studyId, page, perPage);
    }
    // eslint-disable-next-line
  }, [page, studyId]);

  // -----------------------------------------
  // API call to GET ping templates
  // -----------------------------------------
  const fetchPingTemplates = async (studyId, currentPage, itemsPerPage) => {
    setLoading(true);
    setError(null);

    try {
      const response = await axios.get(
        `/studies/${studyId}/ping_templates?page=${currentPage}&per_page=${itemsPerPage}`
      );
      const { data, meta } = response.data;

      setPingTemplates(data);
      setPage(meta.page);
      setTotalPages(meta.pages);
    } catch (err) {
      console.error(err);
      setError('Error fetching ping templates');
    } finally {
      setLoading(false);
    }
  };

  // -----------------------------------------
  // Handle creating a new ping template
  // -----------------------------------------
  const handleCreatePingTemplate = async (e) => {
    e.preventDefault();

    try {
      // If the user typed JSON for schedule, parse it
      const scheduleParsed = schedule ? JSON.parse(schedule) : null;

      await axios.post(`/studies/${studyId}/ping_templates`, {
        name,
        message,
        url,
        reminder_latency: reminderLatency,
        expire_latency: expireLatency,
        schedule: scheduleParsed,
      });

      // Reset form fields
      setName('');
      setMessage('');
      setUrl('');
      setReminderLatency('');
      setExpireLatency('');
      setSchedule('');

      // Hide the form
      setShowCreateForm(false);

      // Re-fetch ping templates
      fetchPingTemplates(studyId, page, perPage);
    } catch (err) {
      console.error(err);
      setError('Error creating ping template');
    }
  };

  // -----------------------------------------
  // Simple pagination handlers
  // -----------------------------------------
  const handlePreviousPage = () => {
    if (page > 1) {
      setPage((prev) => prev - 1);
    }
  };

  const handleNextPage = () => {
    if (page < totalPages) {
      setPage((prev) => prev + 1);
    }
  };

  // -----------------------------------------
  // Render fallback if studyId is missing
  // -----------------------------------------
  if (!studyId) {
    return <div>Error: Missing studyId in the URL.</div>;
  }

  // -----------------------------------------
  // Render
  // -----------------------------------------
  return (
    <div style={{ margin: '2rem' }}>
      <StudyNav />
      <h1>Ping Templates for Study #{studyId}</h1>

      <button
        style={{ marginBottom: '1rem' }}
        onClick={() => setShowCreateForm(!showCreateForm)}
      >
        {showCreateForm ? 'Cancel' : 'Create New Ping Template'}
      </button>

      {showCreateForm && (
        <section style={{ marginBottom: '2rem' }}>
          <h2>Create a New Ping Template</h2>
          <form onSubmit={handleCreatePingTemplate} style={{ maxWidth: '400px' }}>
            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="name">Name</label>
              <br />
              <input
                id="name"
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                required
              />
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="message">Message</label>
              <br />
              <textarea
                id="message"
                rows={4}
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                required
              />
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="url">URL</label>
              <br />
              <input
                id="url"
                type="text"
                value={url}
                onChange={(e) => setUrl(e.target.value)}
              />
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="reminder">
                Reminder Latency (e.g. 1 hour, 30 minutes)
              </label>
              <br />
              <input
                id="reminder"
                type="text"
                value={reminderLatency}
                onChange={(e) => setReminderLatency(e.target.value)}
              />
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="expire">Expire Latency (e.g. 24 hours)</label>
              <br />
              <input
                id="expire"
                type="text"
                value={expireLatency}
                onChange={(e) => setExpireLatency(e.target.value)}
              />
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="schedule">Schedule (JSON)</label>
              <br />
              <textarea
                id="schedule"
                rows={4}
                value={schedule}
                onChange={(e) => setSchedule(e.target.value)}
                placeholder='e.g. [{"day":1,"time":"09:00:00"}]'
              />
            </div>

            <button type="submit">Create Ping Template</button>
          </form>
        </section>
      )}

      <section>
        <h2>Your Ping Templates</h2>
        {loading && <p>Loading ping templates...</p>}
        {error && <p style={{ color: 'red' }}>{error}</p>}

        {!loading && !error && (
          <>
            {pingTemplates.length === 0 ? (
              <p>No ping templates found.</p>
            ) : (
              <table
                border="1"
                cellPadding="8"
                style={{ borderCollapse: 'collapse' }}
              >
                <thead>
                  <tr>
                    <th>ID</th>
                    <th>Name</th>
                    <th>Message</th>
                    <th>URL</th>
                    <th>Reminder Latency</th>
                    <th>Expire Latency</th>
                    <th>Schedule</th>
                  </tr>
                </thead>
                <tbody>
                  {pingTemplates.map((pt) => (
                    <tr key={pt.id}>
                      <td>{pt.id}</td>
                      <td>{pt.name}</td>
                      <td>{pt.message}</td>
                      <td>{pt.url}</td>
                      <td>{pt.reminder_latency}</td>
                      <td>{pt.expire_latency}</td>
                      <td>{JSON.stringify(pt.schedule)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </>
        )}

        {/* Simple Pagination Controls */}
        <div style={{ marginTop: '1rem' }}>
          <button onClick={handlePreviousPage} disabled={page <= 1}>
            Previous
          </button>
          <span style={{ margin: '0 1rem' }}>
            Page {page} of {totalPages}
          </span>
          <button onClick={handleNextPage} disabled={page >= totalPages}>
            Next
          </button>
        </div>
      </section>
    </div>
  );
}

export default PingTemplateDashboard;```

flask_app/blueprints/pings.py
```
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from sqlalchemy import or_, and_
from app import db
from models import User, Ping, Study, UserStudy

pings_bp = Blueprint('pings', __name__)

def get_current_user():
    """Helper function to get the current user object from the JWT."""
    user_id = get_jwt_identity()
    if not user_id:
        current_app.logger.warning("JWT identity is missing.")
        return None
    user = db.session.get(User, user_id)
    if not user:
        current_app.logger.warning(f"User with id {user_id} not found.")
    return user

def user_has_study_access(user, study_id):
    """
    Helper function to check if the user is part of (has access to) the given study_id.
    Returns the Study object if found; otherwise returns None.
    """
    study = (
        db.session.query(Study)
        .join(UserStudy)
        .filter(UserStudy.study_id == study_id, UserStudy.user_id == user.id)
        .first()
    )
    if not study:
        current_app.logger.info(f"User {user.id} does not have access to study {study_id}.")
    return study

def user_has_ping_access(user, ping_id):
    """
    Helper function to check if the user has access to the ping.
    We'll do this by checking if the ping's study_id is accessible by the user.
    """
    ping = db.session.get(Ping, ping_id)
    if not ping:
        return None

    # Now check if user has access to this ping's study
    study = user_has_study_access(user, ping.study_id)
    if not study:
        return None

    return ping

@pings_bp.route('/pings', methods=['GET'])
@jwt_required()
def get_pings():
    """
    GET /pings
    Optionally supports some filtering (advanced search) via query params.
    For example: ?study_id=1&day_num=2&message=morning
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    current_app.logger.info(f"User {user.email} requested pings with filter {request.args}.")

    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    # Optional query params for "advanced search"
    study_id = request.args.get('study_id', type=int)
    day_num = request.args.get('day_num', type=int)
    message = request.args.get('message', type=str)
    enrollment_id = request.args.get('enrollment_id', type=int)

    # Base query: only pings in studies that the user can access
    # We can filter by checking pings that are in a "study" that the user is joined with.
    # A simpler approach is to query all pings, then join to user_study, but that might be more complex.
    # We'll do a sub-query approach: fetch study_ids user can access, then filter by them.
    accessible_study_ids = (
        db.session.query(UserStudy.study_id)
        .filter(UserStudy.user_id == user.id)
        .subquery()
    )

    query = db.session.query(Ping).filter(Ping.study_id.in_(accessible_study_ids))

    # Apply optional filters
    if study_id:
        query = query.filter(Ping.study_id == study_id)
    if day_num is not None:
        query = query.filter(Ping.day_num == day_num)
    if message:
        # Example: partial match on ping message
        query = query.filter(Ping.message.ilike(f"%{message}%"))
    if enrollment_id:
        query = query.filter(Ping.enrollment_id == enrollment_id)

    query = query.order_by(Ping.scheduled_ts.asc())

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    pings_list = []
    for p in pagination.items:
        pings_list.append({
            "id": p.id,
            "study_id": p.study_id,
            "ping_template_id": p.ping_template_id,
            "enrollment_id": p.enrollment_id,
            "scheduled_ts": p.scheduled_ts.isoformat() if p.scheduled_ts else None,
            "expire_ts": p.expire_ts.isoformat() if p.expire_ts else None,
            "reminder_ts": p.reminder_ts.isoformat() if p.reminder_ts else None,
            "day_num": p.day_num,
            "message": p.message,
            "url": p.url,
            "ping_sent": p.ping_sent,
            "reminder_sent": p.reminder_sent
        })

    return jsonify({
        "data": pings_list,
        "meta": {
            "page": pagination.page,
            "per_page": pagination.per_page,
            "total": pagination.total,
            "pages": pagination.pages
        }
    }), 200

@pings_bp.route('/pings', methods=['POST'])
@jwt_required()
def create_ping():
    """
    POST /pings
    Requires study_id. The user must have access to that study.
    Other fields are optional or required based on your model logic.
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    data = request.get_json()
    study_id = data.get('study_id')

    # Check user has access to this study
    study = user_has_study_access(user, study_id)
    if not study:
        return jsonify({"error": "No access to study"}), 403

    # Required fields for pings
    enrollment_id = data.get('enrollment_id')
    scheduled_ts = data.get('scheduled_ts')  # e.g. "2024-01-01T09:00:00"
    day_num = data.get('day_num')

    if not all([study_id, enrollment_id, scheduled_ts, day_num]):
        return jsonify({"error": "Missing required fields: study_id, enrollment_id, scheduled_ts, day_num"}), 400

    # Optional
    ping_template_id = data.get('ping_template_id')
    message = data.get('message')
    url = data.get('url')
    expire_ts = data.get('expire_ts')
    reminder_ts = data.get('reminder_ts')

    try:
        new_ping = Ping(
            study_id=study_id,
            ping_template_id=ping_template_id,
            enrollment_id=enrollment_id,
            scheduled_ts=scheduled_ts,
            expire_ts=expire_ts,
            reminder_ts=reminder_ts,
            day_num=day_num,
            message=message,
            url=url
        )
        db.session.add(new_ping)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error("Error creating ping")
        current_app.logger.exception(e)
        return jsonify({"error": "Internal server error"}), 500

    current_app.logger.info(f"User {user.email} created a new ping with ID {new_ping.id}.")
    return jsonify({
        "message": "Ping created successfully",
        "ping": {
            "id": new_ping.id,
            "study_id": new_ping.study_id,
            "ping_template_id": new_ping.ping_template_id,
            "enrollment_id": new_ping.enrollment_id,
            "scheduled_ts": new_ping.scheduled_ts.isoformat() if new_ping.scheduled_ts else None,
            "expire_ts": new_ping.expire_ts.isoformat() if new_ping.expire_ts else None,
            "reminder_ts": new_ping.reminder_ts.isoformat() if new_ping.reminder_ts else None,
            "day_num": new_ping.day_num,
            "message": new_ping.message,
            "url": new_ping.url,
            "ping_sent": new_ping.ping_sent,
            "reminder_sent": new_ping.reminder_sent
        }
    }), 201

@pings_bp.route('/pings/<int:ping_id>', methods=['GET'])
@jwt_required()
def get_single_ping(ping_id):
    """
    GET /pings/<ping_id>
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    ping = user_has_ping_access(user, ping_id)
    if not ping:
        return jsonify({"error": "Ping not found or no access"}), 404

    return jsonify({
        "id": ping.id,
        "study_id": ping.study_id,
        "ping_template_id": ping.ping_template_id,
        "enrollment_id": ping.enrollment_id,
        "scheduled_ts": ping.scheduled_ts.isoformat() if ping.scheduled_ts else None,
        "expire_ts": ping.expire_ts.isoformat() if ping.expire_ts else None,
        "reminder_ts": ping.reminder_ts.isoformat() if ping.reminder_ts else None,
        "day_num": ping.day_num,
        "message": ping.message,
        "url": ping.url,
        "ping_sent": ping.ping_sent,
        "reminder_sent": ping.reminder_sent
    }), 200

@pings_bp.route('/pings/<int:ping_id>', methods=['PUT'])
@jwt_required()
def update_ping(ping_id):
    """
    PUT /pings/<ping_id>
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    ping = user_has_ping_access(user, ping_id)
    if not ping:
        return jsonify({"error": "Ping not found or no access"}), 404

    data = request.get_json()

    # Only update fields if they are provided
    if 'ping_template_id' in data:
        ping.ping_template_id = data['ping_template_id']
    if 'enrollment_id' in data:
        ping.enrollment_id = data['enrollment_id']
    if 'scheduled_ts' in data:
        ping.scheduled_ts = data['scheduled_ts']
    if 'expire_ts' in data:
        ping.expire_ts = data['expire_ts']
    if 'reminder_ts' in data:
        ping.reminder_ts = data['reminder_ts']
    if 'day_num' in data:
        ping.day_num = data['day_num']
    if 'message' in data:
        ping.message = data['message']
    if 'url' in data:
        ping.url = data['url']
    if 'ping_sent' in data:
        ping.ping_sent = data['ping_sent']
    if 'reminder_sent' in data:
        ping.reminder_sent = data['reminder_sent']

    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error updating ping {ping_id}")
        current_app.logger.exception(e)
        return jsonify({"error": "Internal server error"}), 500

    current_app.logger.info(f"User {user.email} updated ping {ping_id}.")
    return jsonify({"message": "Ping updated successfully"}), 200

@pings_bp.route('/pings/<int:ping_id>', methods=['DELETE'])
@jwt_required()
def delete_ping(ping_id):
    """
    DELETE /pings/<ping_id>
    """
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    ping = user_has_ping_access(user, ping_id)
    if not ping:
        return jsonify({"error": "Ping not found or no access"}), 404

    try:
        db.session.delete(ping)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting ping {ping_id}")
        current_app.logger.exception(e)
        return jsonify({"error": "Internal server error"}), 500

    current_app.logger.info(f"User {user.email} deleted ping {ping_id}.")
    return jsonify({"message": f"Ping {ping_id} deleted successfully."}), 200```

flask_app/blueprints/enrollments.py
```
from flask import Blueprint, request, g, Response, jsonify, current_app
from flask_jwt_extended import jwt_required
from config import Config
import urllib.parse
from utils import generate_non_confusable_code
from models import Study, Enrollment, Ping, PingTemplate, User
from app import db
from random import randint
from datetime import timedelta, datetime, timezone
import pytz
import secrets


enrollments_bp = Blueprint('enrollments', __name__)


def random_time(start_date: datetime, start_day_num: int, start_time: str, end_day_num: int, end_time: str, tz: str) -> datetime:
    interval_start_date = start_date + timedelta(days=start_day_num)
    interval_end_date = start_date + timedelta(days=end_day_num)
    start_time = datetime.strptime(start_time, '%H:%M').time()
    end_time = datetime.strptime(end_time, '%H:%M').time()
    try:
        tz = pytz.timezone(tz)
    except pytz.exceptions.UnknownTimeZoneError:
        current_app.logger.error(f"Invalid timezone {tz}.")
        return
    interval_start_ts = datetime.combine(interval_start_date, start_time, tzinfo=tz)
    interval_end_ts = datetime.combine(interval_end_date, end_time, tzinfo=tz)
    ping_interval_length = interval_end_ts - interval_start_ts
    ping_time = interval_start_ts + timedelta(seconds=randint(0, ping_interval_length.total_seconds()))
    return ping_time
    
def make_pings(enrollment_id, study_id):
    
    current_app.logger.info(f"Making pings for enrollment {enrollment_id} in study {study_id}")
    
    try:
        # Get enrollment
        enrollment = Enrollment.query.get(enrollment_id)
        if not enrollment:
            current_app.logger.error(f"Enrollment {enrollment_id} not found. Aborting ping creation for study {study.id}.")
            return
        
        # Get study
        study = Study.query.get(study_id)
        if not study:
            current_app.logger.error(f"Study {study_id} not found. Aborting ping creation for participant {enrollment_id}.")
            return
        
        # Get ping templates
        ping_templates = study.ping_templates
        if not ping_templates:
            current_app.logger.error(f"No ping templates found for study {study_id}. Aborting ping creation for participant {enrollment_id}.")
            return
        
        # note some assumptions:
        # signup date is Day 0
        # start time and end time are in format HH:MM
        # schedule is a list of dictionaries with keys 'start_day_num', 'start_time', 'end_day_num', 'end_time'
        pings = []
        for pt in ping_templates:
            for ping in pt.schedule:
                # Generate random time within the ping interval
                ping_time = random_time(start_date=enrollment.start_date, 
                                        start_day_num=ping['start_day_num'],
                                        start_time=ping['start_time'],
                                        end_day_num=ping['end_day_num'], 
                                        end_time=ping['end_time'], 
                                        tz=enrollment.tz)
                # Create ping
                ping = {
                    'enrollment_id': enrollment_id,
                    'study_id': study_id,
                    'ping_template_id': pt.id,
                    'scheduled_ts': ping_time,
                    'expire_ts': ping_time + pt.expire_latency,
                    'reminder_ts': ping_time + pt.reminder_latency,
                    'day_num': ping['start_day_num'],
                    'url': pt.url,
                    'ping_sent': False,
                    'reminder_sent': False 
                }
                pings.append(ping)
                db.session.add(Ping(**ping))
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error creating pings for enrollment {enrollment_id} in study {study_id}")
        current_app.logger.exception(e)
        return
    
    current_app.logger.info(f"Created {len(pings)} pings for enrollment {enrollment_id} in study {study_id}")
    return pings
    
    
@enrollments_bp.route('/signup', methods=['POST'])
def study_signup():
    '''
    This endpoint is used to collect the timezone of a participant and enroll them in a study.
    It also creates pings for the participant based on the study's ping templates (though this may be moved to after collecting telegram ID).
    They still need to have their telegram ID collected and linked to the enrollment.
    The endpoint ultimately returns a unique code for them (and saves it in the database) that they can provide to the telegram bot 
    in order to link their telegram ID to their enrollment.
    '''
    
    data = request.get_json()
    signup_code = data.get('signup_code')
    study_pid = data.get('study_pid')
    tz = data.get('tz')
    
    # Check if signup code is valid 
    study = Study.query.filter_by(code=signup_code).first()
    if not study:
        return jsonify({"error": "Invalid signup code"}), 404
    
    # Generate a unique code for the participant to link their telegram ID
    telegram_link_code = None
    while True:
        telegram_link_code = generate_non_confusable_code(length=6)
        if not Enrollment.query.filter_by(telegram_link_code=telegram_link_code).first():
            break
        
    # Create a new enrollment
    try:
        enrollment = Enrollment(study_id=study.id, 
                                tz=tz,
                                enrolled=True, 
                                study_pid=study_pid,
                                start_date=datetime.now().date(),
                                pr_completed=0.0,
                                telegram_link_code=telegram_link_code,
                                telegram_link_code_expire_ts=datetime.now(timezone.utc) + timedelta(days=current_app.config["TELEGRAM_LINK_CODE_EXPIRY_DAYS"])
                                )
        db.session.add(enrollment)
        db.session.commit()
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error with enrollment in study {study.id} using signup code {signup_code} for study pid {study_pid}")
        current_app.logger.exception(e)
        return jsonify({"error": "Internal server error"}), 500
    
    # Create pings for participant
    pings = make_pings(
        enrollment_id=enrollment.id, 
        study_id=study.id
        )
    if not pings:
        return jsonify({"error": "Internal server error"}), 500
    
    return jsonify({
        "message": "Participant enrolled successfully",
        "telegram_link_code": telegram_link_code,
        "participant_id": enrollment.id,
        "study_id": study.id,
        "study_pid": study_pid,
        "tz": enrollment.tz
    }), 200
    


@enrollments_bp.route('/enrollment/login', methods=['POST'])
def participant_login():
    '''
    This endpoint is used to generate a one-time login link for a participant.
    '''
    
    data = request.get_json()
    telegram_id = data.get('telegram_id')
    
    # Create a new OTP
    otp = secrets.token_urlsafe(16)
    expiry = datetime.now() + timedelta(minutes=current_app.config["ENROLLMENT_DASHBOARD_OTP_EXPIRY_MINS"])
    
```

react_frontend/src/pages/EnrollmentDashboard.js
```
```



- ok now make similar ping dashboard and participant dashboards.
- note that internally i call participant as enrollment, but in the frontend i call it participant.

