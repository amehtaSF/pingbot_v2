
I am making a ecological momentary assessment app with flask backend and react frontend. 
Here are some of the files that I have created so far:


react_frontend/src/App.js
``` python
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import Login from './pages/Login';
import Register from './pages/Register';
import StudyDashboard from './pages/StudyDashboard';
import PingTemplateDashboard from './pages/PingTemplateDashboard';
import StudyEnroll from './pages/StudyEnroll'; 
import PrivateRoute from './components/PrivateRoute';

function App() {
  return (
    <Router>
      <Routes>
        {/* Public routes */}
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />
        <Route path="/enroll/:signup_code" element={<StudyEnroll />} />

        {/* Protected routes */}
        <Route
          path="/studies"
          element={
            <PrivateRoute>
              <StudyDashboard />
            </PrivateRoute>
          }
        />
        <Route
          path="/studies/:studyId/pingtemplates"
          element={
            <PrivateRoute>
              <PingTemplateDashboard />
            </PrivateRoute>
          }
        />

        {/* Catch-all route */}
        <Route path="*" element={<Navigate to="/studies" />} />
      </Routes>
    </Router>
  );
}

export default App;```

flask_app/app.py
``` python
from logger_setup import setup_logger
import json
from flask import Flask, request, jsonify
import os
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
import boto3
from datetime import datetime, timedelta
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import hashlib
from dotenv import load_dotenv
from flask import Response



# Load environment variables
load_dotenv()

# Initialize logger
logger = setup_logger()

# Initialize PostgreSQL database
db = SQLAlchemy()

# Initialize JWT manager
jwt = JWTManager()

def create_app(config='config.Config'):
    
    app = Flask(__name__)
    CORS(app)

    # Attach logger to app
    app.logger = logger
    
    # Load config
    try:
        app.config.from_object(config)
    except Exception as e:
        logger.error(f"Failed to load configuration: {e}")
        raise

    # Extensions
    jwt.init_app(app)
    db.init_app(app)
    
    # # JWT callbacks
    # @jwt.user_identity_loader
    # def user_identity_lookup(user):
    #     """Converts user object to JSON serializable format for JWT."""
    #     return user.id

    # @jwt.user_lookup_loader
    # def user_lookup_callback(_jwt_header, jwt_data):
    #     """Loads user object from the database based on JWT identity."""
    #     from models import User
    #     identity = jwt_data["sub"]
    #     return User.query.filter_by(id=identity).one_or_none()
    
    # Blueprints
    # from blueprints.admin import admin_bp
    from blueprints.auth import auth_bp
    from blueprints.studies import studies_bp
    from blueprints.ping_templates import ping_templates_bp
    # from blueprints.participants import participants_bp
    from blueprints.enrollments import enrollments_bp
    # from blueprints.users import users_bp
    # from blueprints.bot import bot_bp
    
    # app.register_blueprint(admin_bp, url_prefix='/admin')
    app.register_blueprint(auth_bp, url_prefix='/api')
    app.register_blueprint(studies_bp, url_prefix='/api')
    app.register_blueprint(ping_templates_bp, url_prefix='/api')
    # app.register_blueprint(participants_bp, url_prefix='/api')
    app.register_blueprint(enrollments_bp, url_prefix='/api')
    # app.register_blueprint(bot_bp, url_prefix='/bot')
    # app.register_blueprint(users_bp, url_prefix='/')
    
    # @app.before_request
    # def log_request():
    #     print(f"Request received: {request.method} {request.url}")
        
    # Health Check
    @app.route('/health', methods=['GET'])
    def health():
        return {'status': 'healthy'}, 200
    
    # Generic error handling
    @app.errorhandler(Exception)
    def handle_exception(e):
        logger.exception(e)
        return {'error': str(e)}, 500
    
    return app

```

flask_app/models.py
``` python
import os
from datetime import datetime, timezone
from dotenv import load_dotenv
from werkzeug.security import generate_password_hash, check_password_hash

from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy import Interval

from app import db, create_app

load_dotenv()

# ------------------------------------------------
# Enrollments Table (Participants ↔ Studies with attributes)
# ------------------------------------------------
class Enrollment(db.Model):
    __tablename__ = 'enrollments'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    
    telegram_id = db.Column(db.String(100), nullable=True, unique=False)
    tz = db.Column(db.String(50), nullable=False)
    # participant_id = db.Column(db.Integer, db.ForeignKey('participants.id'), nullable=False)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    study_pid = db.Column(db.String(255), nullable=False)  # Participant ID in the study assigned by researcher
    enrolled = db.Column(db.Boolean, default=True, nullable=False)
    start_date = db.Column(db.DateTime(timezone=True), nullable=False)
    pr_completed = db.Column(db.Float, default=0.0)
    created_at = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

    # Relationships
    pings = db.relationship("Ping", back_populates="enrollment")
    study = db.relationship("Study", back_populates="enrollments")
    

# ------------------------------------------------
# UserStudy Table (Users ↔ Studies with attributes)
# ------------------------------------------------
class UserStudy(db.Model):
    __tablename__ = 'user_studies'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    role = db.Column(db.String(255), nullable=False)  # e.g. 'owner': sharing + editing + viewing, 'editor': editing + viewing, 'viewer': viewing only
    created_at = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

    # Relationships
    user = db.relationship("User", back_populates="user_studies")
    study = db.relationship("Study", back_populates="user_studies")

# ------------------------------------------------
# Users Table
# ------------------------------------------------
class User(db.Model):
    __tablename__ = 'users'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    email = db.Column(db.String(255), nullable=False, unique=True)
    password = db.Column(db.String(255), nullable=False)
    first_name = db.Column(db.String(100))
    last_name = db.Column(db.String(100))
    institution = db.Column(db.String(255))
    last_login = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc))
    created_at = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

    # Many-to-many relationship with Study
    user_studies = db.relationship(
        "UserStudy",
        back_populates="user"
    )

    def set_password(self, password):
        """Hash and set the user's password."""
        self.password = generate_password_hash(password)
        
    def check_password(self, password):
        """Check if the provided password matches the stored hash."""
        return check_password_hash(self.password, password)

# ------------------------------------------------
# Studies Table
# ------------------------------------------------
class Study(db.Model):
    __tablename__ = 'studies'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    public_name = db.Column(db.String(255), nullable=False)
    internal_name = db.Column(db.String(255), nullable=False)
    code = db.Column(db.String(255), nullable=False, unique=True)
    contact_message = db.Column(db.Text)  # e.g., "Please contact the study team for any questions or concerns by emailing ashm@stanford.edu."
    created_at = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

    # Relationships
    ping_templates = db.relationship("PingTemplate", back_populates="study")
    pings = db.relationship("Ping", back_populates="study")
    enrollments = db.relationship(
        "Enrollment",
        back_populates="study"
    )
    user_studies = db.relationship(
        "UserStudy",
        back_populates="study"
    ) 
# ------------------------------------------------
# Participants Table
# ------------------------------------------------
# class Participant(db.Model):
#     __tablename__ = 'participants'

#     id = db.Column(db.Integer, primary_key=True, autoincrement=True)
#     telegram_id = db.Column(db.String(100), nullable=True, unique=True)
#     tz = db.Column(db.String(50), nullable=False)
#     created_at = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
#     updated_at = db.Column(db.DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

#     # Relationships
#     pings = db.relationship("Ping", back_populates="participant")
#     enrollments = db.relationship("Enrollment", back_populates="participant")

# ------------------------------------------------
# PingTemplates Table
# ------------------------------------------------
class PingTemplate(db.Model):
    __tablename__ = 'ping_templates'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    name = db.Column(db.String(255), nullable=False)
    message = db.Column(db.Text, nullable=False)
    url = db.Column(db.String(255))
    reminder_latency = db.Column(Interval)  # e.g., '1 hour', '30 minutes'
    expire_latency = db.Column(Interval)    # e.g., '24 hours'
    schedule = db.Column(JSONB, nullable=True)  # e.g.,  [{"start_day_num": 1, "start_time": "09:00", "end_day_num": 1, "end_time": "10:00"}, {"day_num": 2, "start_time": "09:00", "end_time": "10:00"}]
    created_at = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

    # Relationships
    study = db.relationship("Study", back_populates="ping_templates")
    pings = db.relationship("Ping", back_populates="ping_template")

# ------------------------------------------------
# Pings Table
# ------------------------------------------------
class Ping(db.Model):
    __tablename__ = 'pings'

    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    study_id = db.Column(db.Integer, db.ForeignKey('studies.id'), nullable=False)
    ping_template_id = db.Column(db.Integer, db.ForeignKey('ping_templates.id'), nullable=False)
    # participant_id = db.Column(db.Integer, db.ForeignKey('participants.id'), nullable=False)
    enrollment_id = db.Column(db.Integer, db.ForeignKey('enrollments.id'), nullable=False)
    scheduled_ts = db.Column(db.DateTime(timezone=True), nullable=False)
    expire_ts = db.Column(db.DateTime(timezone=True))
    reminder_ts = db.Column(db.DateTime(timezone=True))
    day_num = db.Column(db.Integer, nullable=False)
    message = db.Column(db.Text, nullable=True)
    url = db.Column(db.String(255), nullable=True)
    ping_sent = db.Column(db.Boolean, nullable=False, default=False)
    reminder_sent = db.Column(db.Boolean, nullable=False, default=False)
    created_at = db.Column(db.DateTime(timezone=True), default=datetime.now(timezone.utc), nullable=False)
    updated_at = db.Column(db.DateTime(timezone=True), onupdate=datetime.now(timezone.utc))

    # Relationships
    study = db.relationship("Study", back_populates="pings")
    ping_template = db.relationship("PingTemplate", back_populates="pings")
    enrollment = db.relationship("Enrollment", back_populates="pings")
    # participant = db.relationship("Participant", back_populates="pings")

```

flask_app/blueprints/studies.py
``` python
from flask import Blueprint, request, jsonify, current_app
from flask_jwt_extended import jwt_required, get_jwt_identity
from app import db
from models import User, Study, UserStudy
from utils import generate_non_confusable_code

studies_bp = Blueprint('studies', __name__)

def get_current_user():
    """Helper function to get the current user object from the JWT."""
    user_id = get_jwt_identity()
    if not user_id:
        current_app.logger.warning("JWT identity is missing.")
        return None
    user = db.session.get(User, user_id)
    if not user:
        current_app.logger.warning(f"User with id {user_id} not found.")
    return user

def user_owns_study(user, study_id):
    """
    Helper function to check if the user is part of (has access to) the given study_id.
    Returns the Study object if found; otherwise returns None.
    """
    study = (
        db.session.query(Study)
        .join(UserStudy)
        .filter(UserStudy.study_id == study_id, UserStudy.user_id == user.id)
        .first()
    )
    if not study:
        current_app.logger.info(f"User {user.id} does not own study {study_id}.")
    return study

@studies_bp.route('/studies', methods=['GET'])
@jwt_required()
def get_studies():
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    current_app.logger.info(f"User {user.email} requested studies.")

    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)

    query = (
        db.session.query(Study)
        .join(UserStudy)
        .filter(UserStudy.user_id == user.id)
        .order_by(Study.id.asc())
    )

    pagination = query.paginate(page=page, per_page=per_page, error_out=False)
    studies_list = [
        {"id": st.id, "public_name": st.public_name, "internal_name": st.internal_name, "code": st.code}
        for st in pagination.items
    ]

    current_app.logger.info(f"User {user.email} fetched {len(studies_list)} studies.")

    return jsonify({
        "data": studies_list,
        "meta": {
            "page": pagination.page,
            "per_page": pagination.per_page,
            "total": pagination.total,
            "pages": pagination.pages
        }
    }), 200

@studies_bp.route('/studies', methods=['POST'])
@jwt_required()
def create_study():
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    data = request.get_json()
    public_name = data.get('public_name')
    internal_name = data.get('internal_name')
    role = "owner"

    if not public_name or not internal_name:
        current_app.logger.error("Missing required fields: public_name or internal_name.")
        return jsonify({"error": "Missing required fields: public_name, internal_name"}), 400
    
    # Generate a unique study code used for signups
    study_code = None
    while not study_code:
        code = generate_non_confusable_code(length=8)
        if not Study.query.filter_by(code=code).first():
            study_code = code

    # Create the new study 
    try:
        new_study = Study(public_name=public_name, internal_name=internal_name, code=study_code)
        db.session.add(new_study)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error creating study")
        current_app.logger.exception(e)
        return jsonify({"error": "Internal server error"}), 500
    
    # Add the user as the owner of the study
    try:
        user_study = UserStudy(user_id=user.id, study_id=new_study.id, role=role)
        db.session.add(user_study)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error adding user {user.id} as owner of study {new_study.id}")
        current_app.logger.exception(e)
        return jsonify({"error": "Internal server error"}), 500

    current_app.logger.info(f"User {user.email} created a new study with ID {new_study.id}.")

    return jsonify({
        "message": "Study created successfully",
        "study": {"id": new_study.id, "public_name": new_study.public_name, "internal_name": new_study.internal_name, "code": new_study.code}
    }), 201

@studies_bp.route('/studies/<int:study_id>', methods=['GET'])
@jwt_required()
def get_single_study(study_id):
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    study = user_owns_study(user, study_id)
    if not study:
        current_app.logger.warning(f"Study {study_id} not found or user {user.id} has no access.")
        return jsonify({"error": f"Study {study_id} not found or no access"}), 404

    current_app.logger.info(f"User {user.email} accessed study {study_id}.")
    return jsonify({
        "id": study.id, 
        "public_name": study.public_name, 
        "internal_name": study.internal_name,
        "code": study.code
        }), 200

@studies_bp.route('/studies/<int:study_id>', methods=['PUT'])
@jwt_required()
def update_study(study_id):
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    study = user_owns_study(user, study_id)
    if not study:
        current_app.logger.warning(f"Study {study_id} not found or user {user.id} has no access.")
        return jsonify({"error": f"Study {study_id} not found or no access"}), 404

    data = request.get_json()
    if 'public_name' in data:
        study.public_name = data['public_name']
    if 'internal_name' in data:
        study.internal_name = data['internal_name']

    db.session.commit()

    current_app.logger.info(f"User {user.email} updated study {study_id}.")
    return jsonify({
        "message": "Study updated successfully",
        "study": {"id": study.id, "public_name": study.public_name, "internal_name": study.internal_name}
    }), 200

@studies_bp.route('/studies/<int:study_id>', methods=['DELETE'])
@jwt_required()
def delete_study(study_id):
    user = get_current_user()
    if not user:
        return jsonify({"error": "User not found"}), 404

    study = user_owns_study(user, study_id)
    if not study:
        current_app.logger.warning(f"Study {study_id} not found or user {user.id} has no access.")
        return jsonify({"error": f"Study {study_id} not found or no access"}), 404

    db.session.delete(study)
    db.session.commit()

    current_app.logger.info(f"User {user.email} deleted study {study_id}.")
    return jsonify({"message": f"Study {study_id} deleted successfully."}), 200
```

react_frontend/src/pages/StudyDashboard.js
``` python
import React, { useEffect, useState } from 'react';
import axios from '../api/axios';

function StudyDashboard() {
  // -----------------------------------------
  // State
  // -----------------------------------------
  const [studies, setStudies] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Pagination
  const [page, setPage] = useState(1);
  const [perPage] = useState(5);
  const [totalPages, setTotalPages] = useState(1);

  // Form fields for creating a new study
  const [publicName, setPublicName] = useState('');
  const [internalName, setInternalName] = useState('');
  const [signupCode] = useState(''); // Auto-generated

  // -----------------------------------------
  // NEW: Toggles whether the "Create Study" form is shown
  // -----------------------------------------
  const [showCreateForm, setShowCreateForm] = useState(false);

  // -----------------------------------------
  // Fetch studies on component mount or when page changes
  // -----------------------------------------
  useEffect(() => {
    fetchStudies(page, perPage);
    // eslint-disable-next-line
  }, [page]);

  // -----------------------------------------
  // API call to GET /studies
  // -----------------------------------------
  const fetchStudies = async (currentPage, itemsPerPage) => {
    setLoading(true);
    setError(null);

    try {
      const response = await axios.get(
        `/studies?page=${currentPage}&per_page=${itemsPerPage}`
      );

      const { data, meta } = response.data;
      setStudies(data);
      setPage(meta.page);
      setTotalPages(meta.pages);
    } catch (err) {
      console.error(err);
      setError('Error fetching studies');
    } finally {
      setLoading(false);
    }
  };

  // -----------------------------------------
  // Handle creating a new study (POST /studies)
  // -----------------------------------------
  const handleCreateStudy = async (e) => {
    e.preventDefault();

    try {
      await axios.post('/studies', {
        public_name: publicName,
        internal_name: internalName,
        code: signupCode,
      });

      // Reset form fields
      setPublicName('');
      setInternalName('');

      // Optionally hide the form after successful creation
      setShowCreateForm(false);

      // Re-fetch the studies list
      fetchStudies(page, perPage);
    } catch (err) {
      console.error(err);
      setError('Error creating study');
    }
  };

  // -----------------------------------------
  // Simple pagination handlers
  // -----------------------------------------
  const handlePreviousPage = () => {
    if (page > 1) {
      setPage((prev) => prev - 1);
    }
  };

  const handleNextPage = () => {
    if (page < totalPages) {
      setPage((prev) => prev + 1);
    }
  };

  // -----------------------------------------
  // Render
  // -----------------------------------------
  return (
    <div style={{ margin: '2rem' }}>
      <h1>Studies Dashboard</h1>

      {/* 
        NEW: Button to toggle form visibility 
      */}
      <button
        style={{ marginBottom: '1rem' }}
        onClick={() => setShowCreateForm(!showCreateForm)}
      >
        {showCreateForm ? 'Cancel' : 'Create New Study'}
      </button>

      {/* 
        NEW: Conditionally render the "Create Study" form 
      */}
      {showCreateForm && (
        <section style={{ marginBottom: '2rem' }}>
          <h2>Create a New Study</h2>
          <form onSubmit={handleCreateStudy} style={{ maxWidth: '400px' }}>
            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="publicName">Public Name</label><br />
              <input
                id="publicName"
                type="text"
                value={publicName}
                onChange={(e) => setPublicName(e.target.value)}
                required
              />
            </div>

            <div style={{ marginBottom: '1rem' }}>
              <label htmlFor="internalName">Internal Name</label><br />
              <input
                id="internalName"
                type="text"
                value={internalName}
                onChange={(e) => setInternalName(e.target.value)}
                required
              />
            </div>

            <button type="submit">Create Study</button>
          </form>
        </section>
      )}

      {/* Display Studies in a table */}
      <section>
        <h2>Your Studies</h2>
        {loading && <p>Loading studies...</p>}
        {error && <p style={{ color: 'red' }}>{error}</p>}

        {!loading && !error && (
          <>
            {studies.length === 0 ? (
              <p>No studies found.</p>
            ) : (
              <table border="1" cellPadding="8" style={{ borderCollapse: 'collapse' }}>
                <thead>
                  <tr>
                    <th>ID</th>
                    <th>Public Name</th>
                    <th>Internal Name</th>
                    <th>Signup Code</th>
                  </tr>
                </thead>
                <tbody>
                  {studies.map((study) => (
                    <tr key={study.id}>
                      <td>{study.id}</td>
                      <td>{study.public_name}</td>
                      <td>{study.internal_name}</td>
                      <td>{study.code}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            )}
          </>
        )}

        {/* Simple Pagination Controls */}
        <div style={{ marginTop: '1rem' }}>
          <button onClick={handlePreviousPage} disabled={page <= 1}>
            Previous
          </button>
          <span style={{ margin: '0 1rem' }}>
            Page {page} of {totalPages}
          </span>
          <button onClick={handleNextPage} disabled={page >= totalPages}>
            Next
          </button>
        </div>
      </section>
    </div>
  );
}

export default StudyDashboard;```



make a file pings.py in the blueprints folder. make crud routes similar to what you see with studies.py.

then make a file PingDashboard.js in the pages folder. make a component that lists all the pings that belong to the current user. 
provide an advanced search feature that allows the user to search in a field specific way and filter the pings.
They should also have functionality to create, update, and delete pings.
updating should be done by allowing them to click on the ping and then updating the fields in a form.

